#!/usr/bin/perl -w
######################################################################
#
# $Id: ftimes-xformer,v 1.61 2019/03/14 16:07:44 klm Exp $
#
######################################################################
#
# Copyright 2007-2019 The FTimes Project, All Rights Reserved.
#
######################################################################
#
# Purpose: Tranform FTimes data based on user-specified input.
#
######################################################################

use strict;
use Cwd;
use File::Basename;
use FindBin qw($Bin $RealBin); use lib ("$Bin/../lib/perl5/site_perl", "$RealBin/../lib/perl5/site_perl", "/usr/local/ftimes/lib/perl5/site_perl");
use FTimes::EadRoutines 1.025;
use Getopt::Std;

BEGIN
{
  ####################################################################
  #
  # The Properties hash is essentially private. Those parts of the
  # program that wish to access or modify the data in this hash need
  # to call GetProperties() to obtain a reference.
  #
  ####################################################################

  my (%hProperties);

  sub GetProperties
  {
    return \%hProperties;
  }
}

######################################################################
#
# Main Routine
#
######################################################################

  ####################################################################
  #
  # Punch in and go to work.
  #
  ####################################################################

  my ($phProperties);

  $phProperties = GetProperties();

  $$phProperties{'Program'} = basename(__FILE__);

  $$phProperties{'OctFormat'} = "0%o";
  $$phProperties{'DecFormat'} = "%d";
  $$phProperties{'HexFormat'} = "0x%x";

  $$phProperties{'Newline'} = "\n";

  ####################################################################
  #
  # FTimes fields.
  #
  ####################################################################

  my %hFTimesFields =
  (
    'action'      => 0, # ftimes-srm (common)
    'altstreams'  => 0, # ftimes map (WINX)
    'ams'         => 0, # ftimes map (WINX)
    'atime'       => 0, # ftimes map (common)
    'attributes'  => 0, # ftimes map (WINX)
    'basename'    => 0, # ftimes-xformer
    'category'    => 0, # ftimes compare
    'changed'     => 0, # ftimes compare
    'chms'        => 0, # ftimes map (WINX)
    'chtime'      => 0, # ftimes map (WINX)
    'class'       => 0, # rtimes map
    'cms'         => 0, # ftimes map (WINX)
    'ctime'       => 0, # ftimes map (common)
    'ctx_offset'  => 0, # ftimes-dig2ctx
    'ctx_string'  => 0, # ftimes-dig2ctx
    'dacl'        => 0, # rtimes map
    'data'        => 0, # rtimes map
    'dev'         => 0, # ftimes map (UNIX)
    'dig_name'    => 0, # ftimes-dig2ctx
    'dig_offset'  => 0, # ftimes-dig2ctx
    'dig_string'  => 0, # ftimes-dig2ctx
    'directory'   => 0, # ftimes-xformer
    'extension'   => 0, # ftimes-xformer
    'filename'    => 0, # ftimes-xformer
    'findex'      => 0, # ftimes map (WINX)
    'flags'       => 0, # rtimes map
    'gid'         => 0, # ftimes map (UNIX)
    'gsid'        => 0, # ftimes compare and map (WINX); rtimes map
    'hostname'    => 0, # ftimes-cmp2dbi; ftimes-dig2dbi; ftimes-map2dbi
    'inode'       => 0, # ftimes map (UNIX)
    'joiner'      => 0, # ftimes-cmp2dbi; ftimes-dig2dbi; ftimes-map2dbi
    'lh_length'   => 0, # ftimes-dig2ctx
    'magic'       => 0, # ftimes map (common)
    'md5'         => 0, # ftimes map (common)
    'mh_length'   => 0, # ftimes-dig2ctx
    'mms'         => 0, # ftimes map (WINX)
    'mode'        => 0, # ftimes map (UNIX)
    'mtime'       => 0, # ftimes map (common)
    'name'        => 0, # ftimes compare, dig, and map (common); rtimes map
    'nlink'       => 0, # ftimes map (UNIX)
    'offset'      => 0, # ftimes dig
    'osid'        => 0, # ftimes compare and map (WINX); rtimes map
    'rdev'        => 0, # ftimes map (UNIX)
    'reason'      => 0, # ftimes-srm (common)
    'records'     => 0, # ftimes compare
    'rh_length'   => 0, # ftimes-dig2ctx
    'sha1'        => 0, # ftimes map (common)
    'sha256'      => 0, # ftimes map (common)
    'size'        => 0, # ftimes map (common)
    'status'      => 0, # ftimes-srm (common)
    'string'      => 0, # ftimes dig
    'tag'         => 0, # ftimes dig
    'type'        => 0, # ftimes dig; rtimes map
    'uid'         => 0, # ftimes map (UNIX)
    'unknown'     => 0, # ftimes compare
    'volume'      => 0, # ftimes map (WINX)
    'wtime'       => 0, # rtimes map
    'z_altstreams' => 0, # ftimes map (compressed WINX)
    'z_ams'        => 0, # ftimes map (compressed WINX)
    'z_atime'      => 0, # ftimes map (compressed common)
    'z_attributes' => 0, # ftimes map (compressed WINX)
    'z_chms'       => 0, # ftimes map (compressed WINX)
    'z_chtime'     => 0, # ftimes map (compressed WINX)
    'z_cms'        => 0, # ftimes map (compressed WINX)
    'z_ctime'      => 0, # ftimes map (compressed common)
    'z_dev'        => 0, # ftimes map (compressed UNIX)
    'z_findex'     => 0, # ftimes map (compressed WINX)
    'z_gid'        => 0, # ftimes map (compressed UNIX)
    'z_inode'      => 0, # ftimes map (compressed UNIX)
    'z_magic'      => 0, # ftimes map (compressed common)
    'z_md5'        => 0, # ftimes map (compressed common)
    'z_mms'        => 0, # ftimes map (compressed WINX)
    'z_mode'       => 0, # ftimes map (compressed UNIX)
    'z_mtime'      => 0, # ftimes map (compressed common)
    'z_name'       => 0, # ftimes map (compressed common)
    'z_nlink'      => 0, # ftimes map (compressed UNIX)
    'z_rdev'       => 0, # ftimes map (compressed UNIX)
    'z_sha1'       => 0, # ftimes map (compressed common)
    'z_sha256'     => 0, # ftimes map (compressed common)
    'z_size'       => 0, # ftimes map (compressed common)
    'z_uid'        => 0, # ftimes map (compressed UNIX)
    'z_volume'     => 0, # ftimes map (compressed WINX)
  );

  $$phProperties{'FTimesFields'} = \%hFTimesFields;

  ####################################################################
  #
  # Get Options.
  #
  ####################################################################

  my %hOptions;

  if (!getopts('A:a:B:b:D:d:f:I:i:L:l:o:p:S:s:t:', \%hOptions))
  {
    Usage($$phProperties{'Program'});
  }

  ####################################################################
  #
  # The post-header (after) eval expression, '-A', is optional.
  #
  ####################################################################

  $$phProperties{'PostHeaderEval'} = (exists($hOptions{'A'})) ? $hOptions{'A'} : undef;

  ####################################################################
  #
  # The post-record (after) eval expression, '-a', is optional.
  #
  ####################################################################

  $$phProperties{'PostRecordEval'} = (exists($hOptions{'a'})) ? $hOptions{'a'} : undef;

  ####################################################################
  #
  # The pre-header (before) eval expression, '-B', is optional.
  #
  ####################################################################

  $$phProperties{'PreHeaderEval'} = (exists($hOptions{'B'})) ? $hOptions{'B'} : undef;

  ####################################################################
  #
  # The pre-record (before) eval expression, '-b', is optional.
  #
  ####################################################################

  $$phProperties{'PreRecordEval'} = (exists($hOptions{'b'})) ? $hOptions{'b'} : undef;

  ####################################################################
  #
  # The output field delimiter, '-D', is optional.
  #
  ####################################################################

  $$phProperties{'OutputDelimiter'} = (exists($hOptions{'D'})) ? $hOptions{'D'} : "|";

  if ($$phProperties{'OutputDelimiter'} !~ /^(\\t|[ ,:;=|])$/)
  {
    print STDERR "$$phProperties{'Program'}: Error='Invalid output field delimiter ($$phProperties{'OutputDelimiter'}).'\n";
    exit(2);
  }

  $$phProperties{'OutputDelimiter'} =~ s/\\t/\t/g; # Unescape the tab delimiter.

  ####################################################################
  #
  # The input field delimiter, '-d', is optional.
  #
  ####################################################################

  $$phProperties{'InputDelimiter'} = (exists($hOptions{'d'})) ? $hOptions{'d'} : "|";

  if ($$phProperties{'InputDelimiter'} !~ /^(\\t|[ ,:;=|])$/)
  {
    print STDERR "$$phProperties{'Program'}: Error='Invalid input field delimiter ($$phProperties{'InputDelimiter'}).'\n";
    exit(2);
  }

  $$phProperties{'InputDelimiter'} =~ s/^\|$/\\|/g; # Escape the pipe delimiter.

  ####################################################################
  #
  # An input file, '-f', is required. It can be '-' or a regular file.
  #
  ####################################################################

  if (!exists($hOptions{'f'}))
  {
    Usage($$phProperties{'Program'});
  }
  else
  {
    my $sFile = $hOptions{'f'};
    if ($sFile eq '-')
    {
      $$phProperties{'FileHandle'} = \*STDIN;
    }
    else
    {
      if (!open(FH, "< $sFile"))
      {
        print STDERR "$$phProperties{'Program'}: Error='Unable to open $sFile ($!).'\n";
        exit(2);
      }
      $$phProperties{'FileHandle'} = \*FH;
    }
  }

  ####################################################################
  #
  # The ignore pattern, '-I', is optional.
  #
  ####################################################################

  $$phProperties{'IgnorePattern'} = (exists($hOptions{'I'})) ? $hOptions{'I'} : undef;

  ####################################################################
  #
  # The ignore line count, '-i', is optional.
  #
  ####################################################################

  $$phProperties{'IgnoreNLines'} = (exists($hOptions{'i'})) ? $hOptions{'i'} : 0;

  if ($$phProperties{'IgnoreNLines'} !~ /^\d+$/)
  {
    print STDERR "$$phProperties{'Program'}: Error='Ignore count ($$phProperties{'IgnoreNLines'}) does not pass muster.'\n";
    exit(2);
  }

  ####################################################################
  #
  # The output field list, '-L', is optional.
  #
  ####################################################################

  my (%hActualFieldOrder, %hTargetFieldOrder);

  $$phProperties{'OutputFields'} = (exists($hOptions{'L'})) ? $hOptions{'L'} : undef;

  if (defined($$phProperties{'OutputFields'}))
  {
    my $sIndex = 0;
    foreach my $sField (split(/,/, $$phProperties{'OutputFields'}))
    {
      $hTargetFieldOrder{$sIndex++} = $sField;
    }
  }
  $$phProperties{'TargetFieldOrder'} = \%hTargetFieldOrder;
  $$phProperties{'ActualFieldOrder'} = \%hActualFieldOrder;

  ####################################################################
  #
  # The input field list, '-l', is optional.
  #
  ####################################################################

  $$phProperties{'InputFields'} = (exists($hOptions{'l'})) ? $hOptions{'l'} : undef;

  if (defined($$phProperties{'InputFields'}))
  {
    foreach my $sField (split(/,/, $$phProperties{'InputFields'}))
    {
      $hFTimesFields{$sField} = 0;
    }
  }

  ####################################################################
  #
  # The option list, '-o', is optional.
  #
  ####################################################################

  my @sSupportedOptions =
  (
    'AddDepth',
    'BeQuiet',
    'CountTops',
    'DecodeAttributes',
    'DecodeMode',
    'DeNeuter',
    'DeNeuter:name',
    'DeNeuter:string',
    'DeriveFields',
    'DeriveHeader',
    'HexDump:string',
    'NoHeader',
    'NoQuotes',
    'ParseName',
    'ParseOffset',
  );
  foreach my $sOption (@sSupportedOptions)
  {
    $$phProperties{$sOption} = 0;
  }

  $$phProperties{'Options'} = (exists($hOptions{'o'})) ? $hOptions{'o'} : undef;

  if (defined($$phProperties{'Options'}))
  {
    foreach my $sOption (split(/,/, $$phProperties{'Options'}))
    {
      foreach my $sSupportedOption (@sSupportedOptions)
      {
        $sOption = $sSupportedOption if ($sOption =~ /^$sSupportedOption$/i);
      }
      if (!exists($$phProperties{$sOption}))
      {
        print STDERR "$$phProperties{'Program'}: Error='Unknown or unsupported option ($sOption).'\n";
        exit(2);
      }
      $$phProperties{$sOption} = 1;
    }
  }
  $$phProperties{'AddDepth'} = 1 if ($$phProperties{'CountTops'});
  if ($$phProperties{'DeNeuter'})
  {
    $$phProperties{'DeNeuter:name'} = 1;
    $$phProperties{'DeNeuter:string'} = 1;
  }

  ####################################################################
  #
  # A path strip count, '-p', is optional.
  #
  ####################################################################

  $$phProperties{'PathStripCount'} = (exists($hOptions{'p'})) ? $hOptions{'p'} : 0;

  ####################################################################
  #
  # The split-header eval expression, '-S', is optional.
  #
  ####################################################################

  $$phProperties{'SplitHeaderEval'} = (exists($hOptions{'S'})) ? $hOptions{'S'} : undef;

  ####################################################################
  #
  # The split-record eval expression, '-s', is optional.
  #
  ####################################################################

  $$phProperties{'SplitRecordEval'} = (exists($hOptions{'s'})) ? $hOptions{'s'} : undef;

  ####################################################################
  #
  # An output template, '-t', is optional.
  #
  ####################################################################

  $$phProperties{'Template'} = (exists($hOptions{'t'})) ? $hOptions{'t'} : undef;

  if (defined($$phProperties{'Template'}))
  {
    $$phProperties{'Template'} =~ s/\\n/\n/g; # Convert user specified newlines.
    $$phProperties{'Template'} =~ s/\\r/\r/g; # Convert user specified carriage returns.
    $$phProperties{'Template'} =~ s/\\t/\t/g; # Convert user specified tabs.
  }

  ####################################################################
  #
  # If any arguments remain, it's an error.
  #
  ####################################################################

  if (scalar(@ARGV) > 0)
  {
    Usage($$phProperties{'Program'});
  }

  ####################################################################
  #
  # Skip ignore lines.
  #
  ####################################################################

  for ($$phProperties{'LineNumber'} = 1; $$phProperties{'LineNumber'} <= $$phProperties{'IgnoreNLines'}; $$phProperties{'LineNumber'}++)
  {
    my $sFileHandle = $$phProperties{'FileHandle'}; <$sFileHandle>;
    last if (eof($sFileHandle));
  }

  if ($$phProperties{'LineNumber'} <= $$phProperties{'IgnoreNLines'})
  {
    print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Error='End of file reached while exhausting ignore count ($$phProperties{'IgnoreNLines'}).'\n";
    exit(2);
  }

  ####################################################################
  #
  # Process the header.
  #
  ####################################################################

  my ($sError);

  if (!ProcessHeader($phProperties, \$sError))
  {
    print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Error='$sError'\n";
    exit(2);
  }

  ####################################################################
  #
  # Process the data.
  #
  ####################################################################

  if (!ProcessData($phProperties, \$sError))
  {
    print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Error='$sError'\n";
    exit(2);
  }

  ####################################################################
  #
  # Conditionally log top counts.
  #
  ####################################################################

  if ($$phProperties{'CountTops'})
  {
    foreach my $sTop (sort({ $$phProperties{'NameTops'}{$b} <=> $$phProperties{'NameTops'}{$a} || $a cmp $b } keys(%{$$phProperties{'NameTops'}})))
    {
      print STDERR "Top='$sTop'; Count='$$phProperties{'NameTops'}{$sTop}';\n";
    }
  }

  ####################################################################
  #
  # Clean up and go home.
  #
  ####################################################################

  close($$phProperties{'FileHandle'});

  1;


######################################################################
#
# Depth
#
######################################################################

sub Depth
{
  my ($sPath, $sType) = @_;

  ####################################################################
  #
  # Return a depth of zero if the path is not defined.
  #
  ####################################################################

  if (!defined($sPath))
  {
    return 0;
  }

  ####################################################################
  #
  # Conditionally assign a default value for path type.
  #
  ####################################################################

  if (!defined($sType) || $sType !~ /^(winx|unix)$/io)
  {
    $sType = "unix";
  }

  ####################################################################
  #
  # Conditionally remove quotes.
  #
  ####################################################################

  if ($sPath =~ /^(?:"[^"]+"|'[^']+')$/o)
  {
    $sPath =~ s/^["']//;
    $sPath =~ s/["']$//;
  }

  ####################################################################
  #
  # Split path into pieces.
  #
  ####################################################################

  my @aPieces = ($sType =~ /^winx$/i) ? split(/\\/, $sPath) : split(/\//, $sPath);

  ####################################################################
  #
  # Return the depth (subtract 1 for WINX paths that include a drive).
  #
  ####################################################################

  my $sDepth = scalar(@aPieces);
  if
  (
       ($sType =~ /^unix$/io && (!defined($aPieces[0]) || $aPieces[0] eq ""))
    || ($sType =~ /^winx$/io && (!defined($aPieces[0]) || $aPieces[0] =~ /^(?:|[A-Z]:)$/io)))
  {
    shift(@aPieces);
    $sDepth--;
  }
  GetProperties()->{'NameTops'}{$aPieces[0]}++ if ($sDepth > 0);

  return $sDepth;
}


######################################################################
#
# ProcessHeader
#
######################################################################

sub ProcessHeader
{
  my ($phProperties, $psError) = @_;

  my $phActualFieldOrder = $$phProperties{'ActualFieldOrder'};

  my $phTargetFieldOrder = $$phProperties{'TargetFieldOrder'};

  ####################################################################
  #
  # Read the header line or derive it from the list of input fields.
  #
  ####################################################################

  my $sFileHandle = $$phProperties{'FileHandle'};

  my $sLine = undef;

  if ($$phProperties{'DeriveHeader'})
  {
    if (!defined($$phProperties{'InputFields'}))
    {
      $$psError = "The DeriveHeader option was set, but no input fields were defined.";
      return undef;
    }
    my $sDelimiter = $$phProperties{'InputDelimiter'};
    $sDelimiter =~ s/\\[|]/|/g; # Unescape the pipe delimiter.
    $sLine = join($sDelimiter, split(/,/, $$phProperties{'InputFields'}));
    $$phProperties{'LineNumber'}--;
  }
  elsif ($$phProperties{'DeriveFields'})
  {
    $$phProperties{'LineNumber'}--;
    return 1;
  }
  else
  {
    while ($sLine = <$sFileHandle>)
    {
      $sLine =~ s/[\r\n]+$//;

      ################################################################
      #
      # Conditionally ignore lines that match the specified pattern.
      #
      ################################################################

      if (defined($$phProperties{'IgnorePattern'}) && $sLine =~ /$$phProperties{'IgnorePattern'}/)
      {
        $$phProperties{'LineNumber'}++;
        next;
      }

      ################################################################
      #
      # Ignore FTimes log output (assumes combined output streams).
      #
      ################################################################

      if ($sLine =~ /^[*+<@-]{3}  (?:DEBUGGER|WAYPOINT|LANDMARK|PROPERTY|LOG_WARN|LOG_FAIL|LOG_CRIT|LOG_HOOK|HEX_DUMP)  [*+>@-]{3}[|]/)
      {
        $$phProperties{'LineNumber'}++;
        next;
      }

      ################################################################
      #
      # The first valid line is assumed to be the header.
      #
      ################################################################

      last;
    }
  }

  if (!defined($sLine))
  {
    $$psError = "Header was not defined.";
    return undef;
  }

  ####################################################################
  #
  # Conditionally execute the pre-header eval statement.
  #
  ####################################################################

  if (defined($$phProperties{'PreHeaderEval'}))
  {
    $_ = $sLine;
    eval $$phProperties{'PreHeaderEval'};
    if ($@)
    {
      print STDERR $@;
      $$psError = "Problem with pre-header eval.";
      return undef;
    }
    if (!defined($_) || $_ eq "")
    {
      if (!$$phProperties{'BeQuiet'})
      {
        print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to the pre-header eval.'\n";
      }
      return;
    }
    $sLine = $_;
  }

  ####################################################################
  #
  # Split the input header into fields.
  #
  ####################################################################

  my %H = (); # Header hash.
  my $phHeaderFields = \%H;
  my @aHeaderFields = split(/$$phProperties{'InputDelimiter'}/, $sLine);
  $$phProperties{'HeaderFieldCount'} = scalar(@aHeaderFields);
  for (my $sIndex = 0; $sIndex < $$phProperties{'HeaderFieldCount'}; $sIndex++)
  {
    $$phActualFieldOrder{$sIndex} = $aHeaderFields[$sIndex];
    if (!exists($$phProperties{'FTimesFields'}{$aHeaderFields[$sIndex]}))
    {
      $$psError = "Unrecognized field ($aHeaderFields[$sIndex]). If the input has no header, use the DeriveHeader or DeriveFields options to generate one.";
      return undef;
    }
    $$phHeaderFields{$$phActualFieldOrder{$sIndex}} = $aHeaderFields[$sIndex];
  }

  ####################################################################
  #
  # Conditionally insert {oct,dec,hex}_offset fields.
  #
  ####################################################################

  if ($$phProperties{'ParseOffset'} && defined($$phHeaderFields{'offset'}))
  {
    $$phHeaderFields{'oct_offset'} = "oct_offset";
    $$phHeaderFields{'dec_offset'} = "dec_offset";
    $$phHeaderFields{'hex_offset'} = "hex_offset";
  }

  ####################################################################
  #
  # Conditionally insert directory, filename, basename, and extension
  # fields.
  #
  ####################################################################

  if ($$phProperties{'ParseName'} && defined($$phHeaderFields{'name'}))
  {
    $$phHeaderFields{'directory'} = "directory";
    $$phHeaderFields{'filename'} = "filename";
    $$phHeaderFields{'basename'} = "basename";
    $$phHeaderFields{'extension'} = "extension";
  }

  ####################################################################
  #
  # Conditionally insert depth field.
  #
  ####################################################################

  if ($$phProperties{'AddDepth'} && defined($$phHeaderFields{'name'}))
  {
    $$phHeaderFields{'depth'} = "depth";
  }

  ####################################################################
  #
  # Conditionally execute the split-header eval statement.
  #
  ####################################################################

  if (defined($$phProperties{'SplitHeaderEval'}))
  {
    eval $$phProperties{'SplitHeaderEval'};
    if ($@)
    {
      print STDERR $@;
      $$psError = "Problem with split-header eval.";
      return undef;
    }
    if (!%H)
    {
      if (!$$phProperties{'BeQuiet'})
      {
        print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to the split-header eval.'\n";
      }
      return;
    }
  }

  ####################################################################
  #
  # Generate the output header.
  #
  ####################################################################

  my @aOutput = ();
  my $sOutput = "";

  if (defined($$phProperties{'Template'}))
  {
    if (!$$phProperties{'TemplateIsOk'})
    {
      my $sTemplate = $$phProperties{'Template'};
      foreach my $sField (reverse(sort(keys(%{$$phProperties{'FTimesFields'}}))))
      {
        $sTemplate =~ s/%$sField/(defined($$phHeaderFields{$sField}) ? $$phHeaderFields{$sField} : "")/ge;
      }
      if ($sTemplate =~ /(?:^|[^%])[%](?:[^%]|$)/)
      {
        $$psError = "Template contains unescaped '%'s or unrecognized tokens.";
        return undef;
      }
      my $sCount = 0;
      foreach my $sByte (split(//, $sTemplate))
      {
        $sCount++ if ($sByte =~ /^%$/);
      }
      if ($sCount % 2)
      {
        $$psError = "Template contains an odd number of '%'s.";
        return undef;
      }
      $$phProperties{'TemplateIsOk'} = 1;
    }
    $sOutput = $$phProperties{'Template'};
    foreach my $sField (reverse(sort(keys(%{$$phProperties{'FTimesFields'}}))))
    {
      $sOutput =~ s/%$sField/(defined($$phHeaderFields{$sField}) ? $$phHeaderFields{$sField} : "")/ge;
    }
    $sOutput =~ s/%%/%/g;
  }
  else
  {
    if (defined($$phProperties{'OutputFields'}))
    {
      foreach my $sIndex (sort({ $a <=> $b } keys(%$phTargetFieldOrder)))
      {
        if (!defined($$phHeaderFields{$$phTargetFieldOrder{$sIndex}}))
        {
          if ($$phTargetFieldOrder{$sIndex} =~ /^(directory|filename|basename|extension)$/o)
          {
            $$psError = "Undefined header field ($$phTargetFieldOrder{$sIndex}). Try using the ParseName option.";
          }
          else
          {
            $$psError = "Undefined header field ($$phTargetFieldOrder{$sIndex}).";
          }
          return undef;
        }
        push(@aOutput, $$phHeaderFields{$$phTargetFieldOrder{$sIndex}});
      }
      $sOutput = join($$phProperties{'OutputDelimiter'}, @aOutput);
    }
    else
    {
      foreach my $sIndex (sort({ $a <=> $b } keys(%$phActualFieldOrder)))
      {
        push(@aOutput, $$phHeaderFields{$$phActualFieldOrder{$sIndex}});
      }
      $sOutput = join($$phProperties{'OutputDelimiter'}, @aOutput);
    }
  }

  ####################################################################
  #
  # Conditionally execute the post-header eval statement.
  #
  ####################################################################

  if (defined($$phProperties{'PostHeaderEval'}))
  {
    $_ = $sOutput;
    eval $$phProperties{'PostHeaderEval'};
    if ($@)
    {
      print STDERR $@;
      $$psError = "Problem with post-header eval.";
      return undef;
    }
    if (!defined($_) || $_ eq "")
    {
      if (!$$phProperties{'BeQuiet'})
      {
        print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to the post-header eval.'\n";
      }
      return;
    }
    $sOutput = $_;
  }

  ####################################################################
  #
  # Conditionally spit out the header.
  #
  ####################################################################

  if ($$phProperties{'NoHeader'} == 0)
  {
    print $sOutput, $$phProperties{'Newline'};
  }

  1;
}


######################################################################
#
# ProcessData
#
######################################################################

sub ProcessData
{
  my ($phProperties, $psError) = @_;

  my $phActualFieldOrder = $$phProperties{'ActualFieldOrder'};

  my $phTargetFieldOrder = $$phProperties{'TargetFieldOrder'};

  my $sFileHandle = $$phProperties{'FileHandle'};

  for ($$phProperties{'LineNumber'}++; my $sLine = <$sFileHandle>; $$phProperties{'LineNumber'}++)
  {
    $sLine =~ s/[\r\n]+$//;

    ##################################################################
    #
    # Conditionally ignore lines that match the specified pattern.
    #
    ##################################################################

    if (defined($$phProperties{'IgnorePattern'}) && $sLine =~ /$$phProperties{'IgnorePattern'}/)
    {
      next;
    }

    ##################################################################
    #
    # Ignore FTimes log output (assumes combined output streams).
    #
    ##################################################################

    if ($sLine =~ /^[*+<@-]{3}  (?:DEBUGGER|WAYPOINT|LANDMARK|PROPERTY|LOG_WARN|LOG_FAIL|LOG_CRIT|LOG_HOOK|HEX_DUMP)  [*+>@-]{3}[|]/)
    {
      next;
    }

    ##################################################################
    #
    # Conditionally execute the pre-record eval statement.
    #
    ##################################################################

    if (defined($$phProperties{'PreRecordEval'}))
    {
      $_ = $sLine;
      eval $$phProperties{'PreRecordEval'};
      if ($@)
      {
        print STDERR $@;
        $$psError = "Problem with post-header eval.";
        return undef;
      }
      if (!defined($_) || $_ eq "")
      {
        if (!$$phProperties{'BeQuiet'})
        {
          print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to the pre-record eval.'\n";
        }
        next;
      }
      $sLine = $_;
    }

    ##################################################################
    #
    # Split the input record into fields.
    #
    ##################################################################

    my %R = (); # Record hash.
    my $phRecordFields = \%R;
    my @aRecordFields = split(/$$phProperties{'InputDelimiter'}/, $sLine, -1); # Use large chunk size to preserve trailing NULL fields.
    $$phProperties{'RecordFieldCount'} = scalar(@aRecordFields);
    if ($$phProperties{'DeriveFields'} && !defined($$phProperties{'HeaderFieldCount'}))
    {
      my @aFieldNumbers;
      $$phProperties{'HeaderFieldCount'} = $$phProperties{'RecordFieldCount'};
      for (my $sIndex = 0; $sIndex < $$phProperties{'HeaderFieldCount'}; $sIndex++)
      {
        my $sFieldNumber = $sIndex + 1;
        push(@aFieldNumbers, $sFieldNumber);
        $$phActualFieldOrder{$sIndex} = $sFieldNumber;
        $$phProperties{'FTimesFields'}{$sFieldNumber} = 0;
      }
      $$phProperties{'InputFields'} = join($$phProperties{'InputDelimiter'}, @aFieldNumbers);
    }
    if ($$phProperties{'RecordFieldCount'} != $$phProperties{'HeaderFieldCount'})
    {
      if (!$$phProperties{'BeQuiet'})
      {
        print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to a field count mismatch ($$phProperties{'RecordFieldCount'} != $$phProperties{'HeaderFieldCount'}).'\n";
      }
      next;
    }
    for (my $sIndex = 0; $sIndex < $$phProperties{'HeaderFieldCount'}; $sIndex++)
    {
      $$phRecordFields{$$phActualFieldOrder{$sIndex}} = $aRecordFields[$sIndex];
    }

    ##################################################################
    #
    # Conditionally strip leading directories.
    #
    ##################################################################

    if ($$phProperties{'PathStripCount'})
    {
      if (!defined($$phRecordFields{'name'}))
      {
        if (!$$phProperties{'BeQuiet'})
        {
          print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='The name field must be defined to support the -p option.'\n";
        }
      }
      else
      {
        my $sName = $$phRecordFields{'name'};
        $sName =~ s/^"//;
        $sName =~ s/"$//;
        my $sSeparator = ($sName =~ /\\/) ? "\\" : "/";
        my @aPieces = split(/[\/\\]/, $sName);
        if (scalar(@aPieces) <= $$phProperties{'PathStripCount'})
        {
          if (!$$phProperties{'BeQuiet'})
          {
            print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded because the strip count ($$phProperties{'PathStripCount'}) obliterates the name ($sName).'\n";
          }
          next;
        }
        splice(@aPieces, 0, $$phProperties{'PathStripCount'});
        $$phRecordFields{'name'} = '"' . join($sSeparator, @aPieces) . '"';
      }
    }

    ##################################################################
    #
    # Conditionally remove name quotes.
    #
    ##################################################################

    if ($$phProperties{'NoQuotes'})
    {
      if (!defined($$phRecordFields{'name'}))
      {
        if (!$$phProperties{'BeQuiet'})
        {
          print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='The name field must be defined to support the NoQuotes option.'\n";
        }
      }
      else
      {
        $$phRecordFields{'name'} =~ s/^"//;
        $$phRecordFields{'name'} =~ s/"$//;
      }
    }

    ##################################################################
    #
    # Conditionally deneuter neutered fields.
    #
    ##################################################################

    foreach my $sField ("name", "string")
    {
      my $sOption = "DeNeuter:$sField";
      if ($$phProperties{$sOption})
      {
        if (!defined($$phRecordFields{$sField}))
        {
          if (!$$phProperties{'BeQuiet'})
          {
            print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='The $sField field must be defined to support the DeNeuter or DeNeuter:$sField option.'\n";
          }
        }
        else
        {
          $$phRecordFields{$sField} = EadFTimesUrlDecode($$phRecordFields{$sField});
        }
      }
    }

    ##################################################################
    #
    # Conditionally decode attributes.
    #
    ##################################################################

    if ($$phProperties{'DecodeAttributes'})
    {
      if (defined($$phRecordFields{'attributes'}))
      {
        $$phRecordFields{'attributes'} = EadWinxAttributesDecode($$phRecordFields{'attributes'});
      }
    }

    ##################################################################
    #
    # Conditionally decode mode.
    #
    ##################################################################

    if ($$phProperties{'DecodeMode'})
    {
      if (defined($$phRecordFields{'mode'}))
      {
        $$phRecordFields{'mode'} = EadUnixModeDecode($$phRecordFields{'mode'});
      }
    }

    ##################################################################
    #
    # Conditionally parse offset.
    #
    ##################################################################

    if ($$phProperties{'ParseOffset'} && defined($$phRecordFields{'offset'}))
    {
      my $sOffset = ($$phRecordFields{'offset'} =~ /^0[xb]?/o) ? oct($$phRecordFields{'offset'}) : $$phRecordFields{'offset'};
      $$phRecordFields{'oct_offset'} = sprintf($$phProperties{'OctFormat'}, $sOffset);
      $$phRecordFields{'dec_offset'} = sprintf($$phProperties{'DecFormat'}, $sOffset);
      $$phRecordFields{'hex_offset'} = sprintf($$phProperties{'HexFormat'}, $sOffset);
    }

    ##################################################################
    #
    # Conditionally parse name.
    #
    ##################################################################

    if ($$phProperties{'ParseName'} && defined($$phRecordFields{'name'}))
    {
      my $sName = $$phRecordFields{'name'};
      $sName =~ s/^"//;
      $sName =~ s/"$//;
      fileparse_set_fstype(($sName =~ /\\/o) ? "MSWin32" : "Unix"); # Update this for each record -- the input stream could be mixed (i.e., UNIX and WINX).
      my ($sBasename, $sDirectory, $sExtension) = fileparse($sName, qr/[.][^.]*/); # This suffix expression is not great, but it's better than nothing.
      $sDirectory =~ s/[\/\\]$// unless ($sDirectory =~ /^[\/\\]$/o); # Drop the trailing path separator except for '/' and '\'.
      $$phRecordFields{'directory'} = $sDirectory;
      $$phRecordFields{'filename'} = $sBasename . $sExtension;
      $$phRecordFields{'basename'} = $sBasename;
      $$phRecordFields{'extension'} = $sExtension;
      if (!$$phProperties{'NoQuotes'})
      {
        $$phRecordFields{'directory'} = '"' . $$phRecordFields{'directory'} . '"';
        $$phRecordFields{'filename'} = '"' . $$phRecordFields{'filename'} . '"';
        $$phRecordFields{'basename'} = '"' . $$phRecordFields{'basename'} . '"';
        $$phRecordFields{'extension'} = '"' . $$phRecordFields{'extension'} . '"';
      }
    }

    ##################################################################
    #
    # Conditionally compute depth.
    #
    ##################################################################

    if ($$phProperties{'AddDepth'} && defined($$phRecordFields{'name'}))
    {
      $$phRecordFields{'depth'} = Depth($$phRecordFields{'name'}, ($$phRecordFields{'name'} =~ /\\/o) ? "winx" : "unix");
    }

    ##################################################################
    #
    # Conditionally execute the split-record eval statement.
    #
    ##################################################################

    if (defined($$phProperties{'SplitRecordEval'}))
    {
      eval $$phProperties{'SplitRecordEval'};
      if ($@)
      {
        print STDERR $@;
        $$psError = "Problem with post-record eval.";
        return undef;
      }
      if (!%R)
      {
        if (!$$phProperties{'BeQuiet'})
        {
          print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to the split-record eval.'\n";
        }
        next;
      }
    }

    ##################################################################
    #
    # Generate the output record.
    #
    ##################################################################

    my @aOutput = ();
    my $sOutput = "";

    if (defined($$phProperties{'Template'}))
    {
      if (!$$phProperties{'TemplateIsOk'})
      {
        my $sTemplate = $$phProperties{'Template'};
        foreach my $sField (reverse(sort(keys(%{$$phProperties{'FTimesFields'}}))))
        {
          $sTemplate =~ s/%$sField/(defined($$phRecordFields{$sField}) ? $$phRecordFields{$sField} : "")/ge;
        }
        if ($sTemplate =~ /(?:^|[^%])[%](?:[^%]|$)/)
        {
          $$psError = "Template contains unescaped '%'s or unrecognized tokens.";
          return undef;
        }
        my $sCount = 0;
        foreach my $sByte (split(//, $sTemplate))
        {
          $sCount++ if ($sByte =~ /^%$/);
        }
        if ($sCount % 2)
        {
          $$psError = "Template contains an odd number of '%'s.";
          return undef;
        }
        $$phProperties{'TemplateIsOk'} = 1;
      }
      $sOutput = $$phProperties{'Template'};
      foreach my $sField (reverse(sort(keys(%{$$phProperties{'FTimesFields'}}))))
      {
        $sOutput =~ s/%$sField/(defined($$phRecordFields{$sField}) ? $$phRecordFields{$sField} : "")/ge;
      }
      $sOutput =~ s/%%/%/g;
    }
    else
    {
      if (defined($$phProperties{'OutputFields'}))
      {
        foreach my $sIndex (sort({ $a <=> $b } keys(%$phTargetFieldOrder)))
        {
          push(@aOutput, (defined($$phRecordFields{$$phTargetFieldOrder{$sIndex}})) ? $$phRecordFields{$$phTargetFieldOrder{$sIndex}} : "");
        }
        $sOutput = join($$phProperties{'OutputDelimiter'}, @aOutput);
      }
      else
      {
        foreach my $sIndex (sort({ $a <=> $b } keys(%$phActualFieldOrder)))
        {
          push(@aOutput, (defined($$phRecordFields{$$phActualFieldOrder{$sIndex}})) ? $$phRecordFields{$$phActualFieldOrder{$sIndex}} : "");
        }
        $sOutput = join($$phProperties{'OutputDelimiter'}, @aOutput);
      }
    }

    ##################################################################
    #
    # Conditionally execute the post-record eval statement.
    #
    ##################################################################

    if (defined($$phProperties{'PostRecordEval'}))
    {
      $_ = $sOutput;
      eval $$phProperties{'PostRecordEval'};
      if ($@)
      {
        print STDERR $@;
        $$psError = "Problem with post-record eval.";
        return undef;
      }
      if (!defined($_) || $_ eq "")
      {
        if (!$$phProperties{'BeQuiet'})
        {
          print STDERR "$$phProperties{'Program'}: Line='$$phProperties{'LineNumber'}' Warning='Record was discarded due to the post-record eval.'\n";
        }
        next;
      }
      $sOutput = $_;
    }

    ##################################################################
    #
    # Spit out the record.
    #
    ##################################################################

    print $sOutput, $$phProperties{'Newline'};

    ##################################################################
    #
    # Spit out an optional hex dump for selected fields.
    #
    ##################################################################

    if ($$phProperties{'HexDump:string'})
    {
      my $sDecoder = ($$phRecordFields{'tag'} =~ /^(\w+)(?::\w+)?$/) ? $1 : "nop";
      my $fDecoder = (defined(EadGetDecoders()->{$sDecoder})) ? EadGetDecoders()->{$sDecoder} : \&EadNopDecode;
      my $paRecords = ($$phProperties{'DeNeuter:string'}) ? EadHexDumpRecords(&$fDecoder($$phRecordFields{'string'})) : EadHexDumpRecords(&$fDecoder(EadFTimesUrlDecode($$phRecordFields{'string'})));
      if (defined($paRecords))
      {
        my $sBaseOffset = (defined($$phRecordFields{'offset'})) ? $$phRecordFields{'offset'} : 0;
        my $sLineOffset = $sBaseOffset;
        foreach my $paRecord (@{$paRecords})
        {
          $sLineOffset += hex($$paRecord[0]);
          printf("@@@  HEX_DUMP  @@@|string|0x%08x|%s|%s%s", $sLineOffset, $$paRecord[1], $$paRecord[2], $$phProperties{'Newline'});
        }
      }
    }
  }

  1;
}


######################################################################
#
# Strip
#
######################################################################

sub Strip
{
  my ($sData, $sClass) = @_;
  $sData =~ s/[$sClass]//g if (defined($sClass) && length($sClass));
  return $sData;
}


######################################################################
#
# Usage
#
######################################################################

sub Usage
{
  my ($sProgram) = @_;
  print STDERR "\n";
  print STDERR "Usage: $sProgram [{-A|-a|-B|-b|-S|-s} eval-block] [{-D|-d} delimiter] [-I pattern] [-i count] [{-L|-l} field[,field[,...]]] [-o option[,option[,...]]] [-p count] [-t template] -f {file|-}\n";
  print STDERR "\n";
  exit(1);
}


=pod

=head1 NAME

ftimes-xformer - Tranform FTimes data based on user-specified input

=head1 SYNOPSIS

B<ftimes-xformer> B<[{-A|-a|-B|-b|-S|-s} eval-block]> B<[{-D|-d} delimiter]> B<[-I pattern]> B<[-i count]> B<[{-L|-l} field[,field[,...]]]> B<[-o option[,option[,...]]]> B<[-p count]> B<[-t template]> B<-f {file|-}>

=head1 DESCRIPTION

This utility takes FTimes data and transforms it according to
user-specified criteria.

=head1 OPTIONS

=over 4

=item B<-A eval-block>

Specifies a post-header eval-block to be executed by Perl after the
output header has been formed.  The eval-block operates on a single
line, which is stored in '$_'.

=item B<-a eval-block>

Specifies a post-record eval-block to be executed by Perl after the
output record has been formed.  The eval-block operates on a single
line, which is stored in '$_'.

=item B<-B eval-block>

Specifies a pre-header eval-block to be executed by Perl before the
output header has been split into individual fields.  The eval-block
operates on a single line, which is stored in '$_'.

=item B<-b eval-block>

Specifies a pre-record eval-block to be executed by Perl before the
output record has been split into individual fields.  The eval-block
operates on a single line, which is stored in '$_'.

=item B<-D delimiter>

Specifies the output field delimiter.  Valid delimiters include the
following characters: tab ('\t'), space (' '), comma (','), colon
(':'), semi-colon (';'), equal ('='), and pipe ('|').  The default
delimiter is a pipe.

=item B<-d delimiter>

Specifies the input field delimiter.  Valid delimiters include the
following characters: tab ('\t'), space (' '), comma (','), colon
(':'), semi-colon (';'), equal ('='), and pipe ('|').  The default
delimiter is a pipe.  Note that parse errors are likely to occur if
the specified delimiter appears in any of the field values.

=item B<-f {file|-}>

Specifies the name of the input file. A value of '-' will cause the
program to read from stdin.

=item B<[-I pattern]>

Specifies a regular expression pattern that is used to ignore matching
input lines.

=item B<[-i count]>

Specifies the number of leading input lines to ignore.

=item B<-L field,[field[,...]]>

Specifies the list of output fields.  The order of the fields in this
list determines their order in the output.  Fields in the input that
are omitted from this list will be omitted from the output.  If the
template option (B<-t>) is used, it takes precedence over this option.

=item B<-l field,[field[,...]]>

Specifies the list of valid input fields.  This option is only needed
in cases where the input contains fields not known to FTimes.  If the
input contains fields not known to FTimes or specified in this list,
the script will abort.

=item B<-o option,[option[,...]]>

Specifies the list of options to apply.  Currently, the following
options are supported:

=over 4

=item AddDepth

Count the number of path elements in the name field and place the
result into the depth field.  Note that the root path (i.e., '/')
is not considered a path element for this calculation.  For Windows
paths, the drive specification (e.g., 'C:') is deemed to be part
of the root path.  Consequently, names such as '/foo', '\foo', and
'C:\foo' will yield a depth of one.

=item BeQuiet

Don't print warning messages.

=item CountTops

Count the number of records that belong to each top-level (i.e.,
left-most) path element in a given name as calculated by the depth
function.  Note that the 'AddDepth' option is implicitly activated
whenever this option is enabled.  Once all record processing is
complete, a set of key/value pairs in the format shown below is
logged to stderr in descending count order.

    Top='<top>'; Count='<count>';

=item DecodeAttributes

Convert attributes into a human-readable form.

=item DecodeMode

Convert mode into a human-readable form -- similar to the output
produced by ls(1).

=item DeNeuter

Remove URL encoding from the name and string fields, when present.
Note that this may cause issues with how the output is rendered
on your terminal (e.g., neutered values can contain special or
non-printable characters).  You may selectively deneuter a given
field using the following qualifying syntax:

    -o DeNeuter:<field>

where <field> is one of 'name' or 'string'.

=item DeriveFields

Assume there is no header, and create field names based on the numeric
position of each field found in the first record.  The first field
name would be '1', the second '2', and so on.  These fields may be
accessed and/or operated on in a split-record eval-block using the
standard notation (e.g., $R{'1'}).  They may also be used in output
templates (e.g., %1). Refer to the B<-s> and B<-t> options for
additional details.

=item DeriveHeader

Construct an artificial header from the list of input fields specified
in the B<-l> command line argument and insert it into the input
stream.  This option is useful in cases where the input file does not
contain its own header.  The artificial header is constructed by
joining the input fields (in the order they were specified) with the
input delimiter (see B<-d> option).  Once inserted into the input
stream, this header is subject to pre- and post-header eval-block
operations (see B<-B> and B<-A> options, respectively).

=item HexDump[:{string}]

Insert a hex dump of the specified field's bytes into the output
stream.

=item NoHeader

Don't print an output header.  Note that this overrides all other
header transformations.

=item NoQuotes

Remove the double quotes that FTimes wraps around each name field.

=item ParseName

Split the name field into its components and place the results into
the following fields: directory, filename, basename, and extension.
The following regular expression is used to pick off the extension:

    [.][^.]*$

=item ParseOffset

Convert the offset field from its default base to octal, decimal,
and hexadecimal and place the results into the following fields,
respectively: oct_offset, dec_offset, and hex_offset.  Values
prefixed with '0x' will be treated as hexadecimal; those prefixed
with a single leading '0' will be treated as octal; all others will
be treated as decimal.  The default format for each field is "%o",
"%d", and "%x", respectively.  If a different format is desired
the 'OctFormat', 'DecFormat', or 'HexFormat' properties may be
altered using a pre-header eval-block (i.e., B<-B>).  For example,
the eval-block shown below causes the hex_offset field to be padded
with leading zeros out to 8 upper case digits.

    -B '$$phProperties{"HexFormat"} = "%08X";'

=back

=item B<-p count>

Specifies a path strip count.  This value can be used to strip away
leading path components in the name field.  This is useful in cases
where you want to compare two snapshots that begin with different
prefixes.  If the strip count is too high, the name field for various
records will be obliterated, and that, in turn, will result in no
output being printed for the affected records.

=item B<-S eval-block>

Specifies a split-header eval-block to be executed by Perl once the
header fields have been split.  The eval-block operates on values
stored in the '%H' hash.  The members of the hash are the field names
obtained from the header line of the input file (e.g., $H{'name'},
$H{'size'}, etc.).  Refer to the token lists documented in the B<-t>
description for the complete list of FTimes fields.

=item B<-s eval-block>

Specifies a split-record eval-block to be executed by Perl once the
record fields have been split.  The eval-block operates on values
stored in the '%R' hash.  The members of the hash are the field names
obtained from the header line of the input file (e.g., $R{'name'},
$R{'size'}, etc.).  Refer to the token lists documented in the B<-t>
description for the complete list of FTimes fields.

=item B<-t template>

Specifies a template for an alternate output format.  All occurrences
of '\n', '\r', or '\t' will be converted to newline, carriage return,
and tab, respectively.  The value '%%' will be converted to '%'.

The following tokens, given that they are defined, may be used to
create custom templates: %altstreams, %ams, %atime, %attributes,
%basename %category, %changed, %chms, %chtime, %cms, %ctime,
%ctx_offset, %ctx_string, %dev, %depth, %dig_name, %dig_offset,
%dig_string, %directory, %extension, %filename, %findex, %gid,
%hostname, %inode, %joiner, %lh_length, %magic, %md5, %mh_length,
%mms, %mode, %mtime, %name, %nlink, %offset, %rdev, %records,
%rh_length, %sha1, %sha256, %size, %string, %tag, %type, %uid,
%unknown, %volume, %z_altstreams, %z_ams, %z_atime, %z_attributes,
%z_chms, %z_chtime, %z_cms, %z_ctime, %z_dev, %z_findex, %z_gid,
%z_inode, %z_magic, %z_md5, %z_mms, %z_mode, %z_mtime, %z_name,
%z_nlink, %z_rdev, %z_sha1, %z_sha256, %z_size, %z_uid, and
%z_volume.

Note that the %directory, %filename, %basename, and %extension fields
are defined only when the name field is in the input stream and the
'ParseName' option is enabled.

Note that the %depth field is defined only when the name field is
in the input stream and the 'AddDepth' option is enabled.

If the B<DeriveFields> option was specified, the tokens %1, %2, etc.
will also be available for use.

=back

=head1 AUTHOR

Klayton Monroe

=head1 SEE ALSO

ftimes(1)

=head1 LICENSE

All documentation and code are distributed under same terms and
conditions as FTimes.

=cut
